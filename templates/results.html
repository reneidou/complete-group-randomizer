{% extends "base.html" %}

{% block title %}Deine Gruppen - Gruppen-Zufallsgenerator{% endblock %}

{% block content %}
    <h2>Deine generierten Gruppen:</h2>
    
    <div class="result-controls">
        <button id="toggle-ratings" class="button button-small">Bewertungen anzeigen</button>
        <button id="share-results" class="button button-small">Ergebnisse teilen</button>
        <div id="share-link" style="display: none; margin-top: 10px;"></div>
    </div>

    <div class="groups-container" id="groups-container">
        {% for group in groups %}
            <div class="group-card" data-group-index="{{ loop.index0 }}">
                <h3>Gruppe {{ loop.index }} 
                    <span class="group-rating" style="display: none;">
                        ({{ group_ratings[loop.index0]|round(2) }})
                    </span>
                </h3>
                <ul>
                    {% for person in group %}
                        <li class="draggable" draggable="true" data-player-name="{{ person }}">
                            {{ person }}
                            <span class="player-rating" style="display: none;">
                                ({{ ratings[person]|default(0)|round(2) }})
                            </span>
                            {% if roles[person] %}
                                <span class="player-role">[{{ roles[person] }}]</span>
                            {% endif %}
                        </li>
                    {% endfor %}
                </ul>
                
                <div class="group-score">
                    <label>Punkte:</label>
                    <input type="number" class="group-score-input" min="0" step="0.1" value="0">
                    <button class="button-x-small save-score">Speichern</button>
                </div>
            </div>
        {% endfor %}
    </div>
    
    <div class="actions-container">
        <button id="undo-btn" class="button" disabled>R체ckg채ngig</button>
        <button id="redo-btn" class="button" disabled>Wiederherstellen</button>
        <button id="recalculate-btn" class="button">Neu berechnen</button>
        <a href="{{ url_for('home') }}" class="button">Neue Gruppen erstellen</a>
    </div>

    <!-- ... Speicherfunktionen ... -->
    
    <script>
        // Drag & Drop Implementierung
        const draggables = document.querySelectorAll('.draggable');
        const groups = document.querySelectorAll('.group-card');
        const history = [];
        let currentState = -1;
        
        draggables.forEach(draggable => {
            draggable.addEventListener('dragstart', () => {
                draggable.classList.add('dragging');
            });
            
            draggable.addEventListener('dragend', () => {
                draggable.classList.remove('dragging');
                saveState();
            });
        });
        
        groups.forEach(group => {
            group.addEventListener('dragover', e => {
                e.preventDefault();
                const afterElement = getDragAfterElement(group, e.clientY);
                const draggable = document.querySelector('.dragging');
                if (afterElement) {
                    group.querySelector('ul').insertBefore(draggable, afterElement);
                } else {
                    group.querySelector('ul').appendChild(draggable);
                }
            });
        });
        
        function getDragAfterElement(container, y) {
            // ... Logik zur Bestimmung der Einf체geposition ...
        }
        
        function saveState() {
            // ... Logik zum Speichern des aktuellen Zustands f체r Undo/Redo ...
        }
        
        // Undo/Redo Funktionen
        document.getElementById('undo-btn').addEventListener('click', () => {
            if (currentState > 0) {
                currentState--;
                restoreState(currentState);
            }
        });
        
        document.getElementById('redo-btn').addEventListener('click', () => {
            if (currentState < history.length - 1) {
                currentState++;
                restoreState(currentState);
            }
        });
        
        // Bewertungen ein-/ausblenden
        document.getElementById('toggle-ratings').addEventListener('click', () => {
            const ratings = document.querySelectorAll('.player-rating, .group-rating');
            ratings.forEach(rating => {
                rating.style.display = rating.style.display === 'none' ? 'inline' : 'none';
            });
        });
        
        // Ergebnisse teilen
        document.getElementById('share-results').addEventListener('click', () => {
            const shareLink = document.getElementById('share-link');
            const link = `${window.location.origin}/share/${generateShareId()}`;
            
            shareLink.innerHTML = `
                <p>Teile diesen Link: <a href="${link}" target="_blank">${link}</a></p>
                <div id="qrcode" style="margin-top: 10px;"></div>
            `;
            
            shareLink.style.display = 'block';
            
            // QR-Code generieren
            new QRCode(document.getElementById('qrcode'), {
                text: link,
                width: 128,
                height: 128
            });
        });
        
        // Punkte speichern und Ratings anpassen
        document.querySelectorAll('.save-score').forEach(button => {
            button.addEventListener('click', function() {
                const groupCard = this.closest('.group-card');
                const groupIndex = groupCard.dataset.groupIndex;
                const score = groupCard.querySelector('.group-score-input').value;
                
                // AJAX-Anfrage zum Speichern der Punkte
                fetch('/save_group_score', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        group_id: "{{ generated_group_id }}",
                        group_index: groupIndex,
                        score: parseFloat(score)
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Bewertungen aktualisieren
                        data.updated_ratings.forEach(player => {
                            const ratingElement = document.querySelector(`[data-player-name="${player.name}"] .player-rating`);
                            if (ratingElement) {
                                ratingElement.textContent = `(${player.new_rating.toFixed(2)})`;
                            }
                        });
                        
                        alert('Punkte erfolgreich gespeichert und Bewertungen aktualisiert!');
                    }
                });
            });
        });
    </script>
{% endblock %}